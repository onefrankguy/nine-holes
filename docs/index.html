<!DOCTYPE html>

<html>
<head>
  <title>game.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="public/stylesheets/normalize.css" />
  <link rel="stylesheet" media="all" href="./docco.css" />
</head>
<body>
  <div class="container">
    <div class="page">

      <div class="header">
        
          <h1>game.js</h1>
        

        
      </div>

      
        
        <p>How do you make a video game?</p>
<p>When I created <a href="https://prolix-app.com/" title="Prolix is a word search game for the iPhone and iPod touch which lets you tweet your scores so your friends can play with you.">Prolix</a>, I didn’t know what I was doing. I had a basic
understanding of web design, but I didn’t know JavaScript. What I wanted was
a video game built on open web standards. Something where I could read the
code and understand it and change the rules and make it my own.</p>
<p>This is that game.</p>
<hr>

        
      
        
        <p><strong>Nine Holes</strong> is an old two-player game. It’s played on a 3 x 3 board and
is reminiscent of tic-tac-toe. Players have three pieces each. They take
turns putting them on the board, and the winner is first to get three in
a row. Unlike tic-tac-toe, diagonals don’t count for a win, and pieces can be
moved after they’re played.</p>
<p>So how do we make that into a video game? Well, let’s start with a board.</p>

        
          <div class='highlight'><pre><span class="hljs-keyword">const</span> Board = {};</pre></div>
        
      
        
        <style>
.board {
  display: inline-grid;
  grid-template-areas:
    ". . ."
    ". . ."
    ". . ."
    ". . ."
    ". . ."
    ;
  border-top: 1px solid gray;
  border-left: 1px solid gray;
}
.board > * {
  border-bottom: 1px solid gray;
  border-right: 1px solid gray;
}
.board > *,
.ranks > *,
.files > * {
  font: 1rem/1 sans-serif;
  width: 1.8rem;
  height: 1.8rem;
  display: flex;
  justify-content: center;
  align-items: center;
}
.layout {
  display: inline-grid;
  grid-template-areas:
    ". ."
    ". ."
    ;
}
.files {
  display: flex;
  flex-direction: row;
}
.x:after {
  content: 'x';
}
.y:after {
  content: 'y';
}
.picked {
  background: pink;
}
</style>

<p>When talking about board games, it’s useful to be able to describe the
players and the moves they make in shorthand. Chess notation used numbers for
ranks (rows) and letters for files (columns). So we can draw a 3 x 3 board
like this:</p>
<div class="layout">
<div class="ranks">
  <div>3</div>
  <div>2</div>
  <div>1</div>
</div>
<div class="board">
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
</div>
<div></div>
<div class="files">
  <div>a</div>
  <div>b</div>
  <div>c</div>
</div>
</div>

<p>We can reference any space on our board as a letter and number. So “a1” is
the space in the lower left corner, and “c3” is the space in the upper right
corner.</p>
<p>Since we used “a” and “b” as column labels, we’ll use X and Y for the
players. In our game, players don’t start with pieces on the board. But in
other games, like Checkers, they do. Let’s extend our board slightly so it
has starting spaces for the pieces.</p>
<div class="layout">
<div class="ranks">
  <div>5</div>
  <div>4</div>
  <div>3</div>
  <div>2</div>
  <div>1</div>
</div>
<div class="board">
  <div class="y"></div>
  <div class="y"></div>
  <div class="y"></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div class="x"></div>
  <div class="x"></div>
  <div class="x"></div>
</div>
<div></div>
<div class="files">
  <div>a</div>
  <div>b</div>
  <div>c</div>
</div>
</div>

<p>Every time we start a new game, that’s what we want the board to look like.
So let’s give ourselves a way to create new game boards.</p>

        
          <div class='highlight'><pre>
Board.create = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
  <span class="hljs-keyword">const</span> files = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>];
  <span class="hljs-keyword">const</span> ranks = [<span class="hljs-string">'1'</span>, <span class="hljs-string">'2'</span>, <span class="hljs-string">'3'</span>, <span class="hljs-string">'4'</span>, <span class="hljs-string">'5'</span>];

  <span class="hljs-keyword">const</span> layout = {};

  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
    ranks.forEach(<span class="hljs-function">(<span class="hljs-params">rank</span>) =&gt;</span> {
      layout[file + rank] = <span class="hljs-string">''</span>;
    });
  });

  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
    layout[<span class="hljs-string">`<span class="hljs-subst">${file}</span>1`</span>] = <span class="hljs-string">'x'</span>;
    layout[<span class="hljs-string">`<span class="hljs-subst">${file}</span>5`</span>] = <span class="hljs-string">'y'</span>;
  });

  <span class="hljs-keyword">return</span> {
    files,
    ranks,
    layout,
  };
};</pre></div>
        
      
        
        <p>The <code>Board.create</code> function returns everything we need to draw a picture of
the game. The board shouldn’t care how it’s rendered. For all it knows, we
could be playing this game on a terminal and drawing it with ASCII text.</p>
<p>Now that we can draw the board, we need a way to move pieces around it. If X
starts by moving from a1 to c4, we can write that as “a1-c4”. If Y responds
by moving b5 to a4, we can write that as “b5-a4”. We can keep both those
moves in a list, <code>[&quot;a1-c4&quot;, &quot;b5-a4&quot;]</code>, and give ourselves a way to make them.</p>

        
          <div class='highlight'><pre>
Board.clone = <span class="hljs-function"><span class="hljs-params">board</span> =&gt;</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(board));

Board.move = <span class="hljs-function">(<span class="hljs-params">board, moves</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> copy = Board.clone(board);

  moves.forEach(<span class="hljs-function">(<span class="hljs-params">move</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> [start, end] = move.split(<span class="hljs-string">'-'</span>);
    copy.layout[end] = copy.layout[start];
    copy.layout[start] = <span class="hljs-string">''</span>;
  });

  <span class="hljs-keyword">return</span> copy;
};</pre></div>
        
      
        
        <p>The <code>Board.move</code> function uses <code>JSON.stringify</code> and <code>JSON.parse</code> to make a
deep copy of a boad before updating it. This keeps the function pure. The
same board and the same moves always give the same output. Pure functions
are easier to debug than functions that mutate state, so we’ll try to write
as many of them as we can.</p>
<p>We now have enough code to run a tiny test. We’ll create a new board, make
two moves on it, and see how the board changes.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testImmutableBoard</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> starting = Board.create();
  <span class="hljs-keyword">const</span> playing = Board.move(starting, [<span class="hljs-string">'a1-c4'</span>, <span class="hljs-string">'b5-a4'</span>]);

  assert(starting[<span class="hljs-string">'a1'</span>] === <span class="hljs-string">'x'</span>);
  assert(starting[<span class="hljs-string">'c4'</span>] === <span class="hljs-string">''</span>);
  assert(starting[<span class="hljs-string">'b5'</span>] === <span class="hljs-string">'y'</span>);
  assert(starting[<span class="hljs-string">'a4'</span>] === <span class="hljs-string">''</span>);

  assert(playing[<span class="hljs-string">'a1'</span>] === <span class="hljs-string">''</span>);
  assert(playing[<span class="hljs-string">'c4'</span>] === <span class="hljs-string">'x'</span>);
  assert(playing[<span class="hljs-string">'b5'</span>] === <span class="hljs-string">''</span>);
  assert(playing[<span class="hljs-string">'a4'</span>] === <span class="hljs-string">'y'</span>);
}());</code></pre><p>Our board looks like it’s working, so let’s put it on the screen.</p>
<hr>

        
      
        
        <p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API" title="Various (MDN): Canvas API">Canvas</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API" title="Various (MDN): WebGL API: 2D and 3D graphics for the web">WebGL</a> are often used to render video games in the browser.
But for a game like ours, where the action isn’t fast, HTML and CSS are quick
enough.</p>
<p>We can draw our board using HTML <code>&lt;div&gt;</code> elements. Using <code>&lt;div&gt;</code>, instead of
a more semantic element like <code>&lt;p&gt;</code>, means we avoid browser quirks with
default CSS rules. Each space on the board  will have its own <code>&lt;div&gt;</code>
element. To make our board easy to reference and manipulate, we’ll give each
<code>&lt;div&gt;</code> an <code>id</code> attributes of the file and rank for that board space.</p>
<pre><code>&lt;div <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"board"</span>&gt;
  <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"a5"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"b5"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"c5"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"a4"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"b4"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"c4"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"a3"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"b3"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"c3"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"a2"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"b2"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"c2"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"a1"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"b1"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  &lt;div id=<span class="hljs-string">"c1"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
&lt;<span class="hljs-regexp">/div&gt;</span></code></pre><p>We can use <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout" title="Various (MDN): CSS Grid Layout">CSS Grid</a> to position the board spaces and <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout" title="Various (MDN): CSS Flexible Box Layout">CSS Flexbox</a> to
keep the content in them centered. A border around the board spaces makes
them visible.</p>
<pre><code>&lt;style&gt;
.board {
  <span class="hljs-attr">display</span>: inline-grid;
  grid-template-areas:
    <span class="hljs-string">". . ."</span>
    <span class="hljs-string">". . ."</span>
    <span class="hljs-string">". . ."</span>
    <span class="hljs-string">". . ."</span>
    <span class="hljs-string">". . ."</span>
    ;
  border-top: <span class="hljs-number">1</span>px solid gray;
  border-left: <span class="hljs-number">1</span>px solid gray;
}

.board &gt; * {
  <span class="hljs-attr">display</span>: flex;
  justify-content: center;
  align-items: center;
  border-bottom: <span class="hljs-number">1</span>px solid gray;
  border-right: <span class="hljs-number">1</span>px solid gray;
}
&lt;<span class="hljs-regexp">/style&gt;</span></code></pre><p>With those rules in place, our board looks like this.</p>
<div class="board">
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
</div>

<p>It’s tempting to use something like <a href="https://api.jquery.com/html/" title="Various (jQuery): jQuery API Documentation - .html()">jQuery’s <code>.html()</code> function</a> to
update the HTML and place “x” and “y” text elements for the pieces.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testHtmlRendering</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">window</span>.jQuery(<span class="hljs-string">'#a1'</span>).html(<span class="hljs-string">'x'</span>);
  <span class="hljs-built_in">window</span>.jQuery(<span class="hljs-string">'#c5'</span>).html(<span class="hljs-string">'y'</span>);
}());</code></pre><p>But that kind of direct manipulation couples the display of the pieces to the
JavaScript code. Instead, we’ll use CSS classes to render “x” and “y”
characters as pseudo elements. That way we can change the pieces later to
look like squares and circles by changing the CSS.</p>
<pre><code>&lt;style&gt;
.x:after {
  <span class="hljs-attr">content</span>: <span class="hljs-string">'x'</span>;
}

.y:after {
  <span class="hljs-attr">content</span>: <span class="hljs-string">'y'</span>;
}
&lt;<span class="hljs-regexp">/style&gt;</span></code></pre><p>Instead of <code>.html()</code> we can use <a href="https://api.jquery.com/addClass/" title="Various (jQuery): jQuery API Documentation - .addClass()">jQuery’s <code>.addClass()</code> function</a>
to render pieces.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testCssRendering</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-built_in">window</span>.jQuery(<span class="hljs-string">'#a1'</span>).addClass(<span class="hljs-string">'x'</span>);
  <span class="hljs-built_in">window</span>.jQuery(<span class="hljs-string">'#c5'</span>).addClass(<span class="hljs-string">'y'</span>);
}());</code></pre><p>The other thing we need to figure out is user feedback. We can set a <code>picked</code>
class on board spaces when the user selects them, and change the background
color to show they’ve been picked.</p>
<pre><code>&lt;style&gt;
.picked {
  <span class="hljs-attr">background</span>: pink;
}
&lt;<span class="hljs-regexp">/style&gt;</span></code></pre><p>So how do we render a board with pieces on It?</p>
<p>The keys in our <code>board.layout</code> object match the <code>id</code> elements of our board
HTML. And the values in our <code>board.layout</code> object match the classes we use
for styling board spaces. So we can render a board by iterating through its
layout.</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">const</span> Renderer = {};

Renderer.render = <span class="hljs-function">(<span class="hljs-params">board, picked</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">window</span>.jQuery;

  <span class="hljs-built_in">Object</span>.keys(board.layout).forEach(<span class="hljs-function">(<span class="hljs-params">id</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> element = $(<span class="hljs-string">`#<span class="hljs-subst">${id}</span>`</span>);
    element.removeClass(<span class="hljs-string">'picked'</span>);
    element.removeClass(<span class="hljs-string">'x'</span>);
    element.removeClass(<span class="hljs-string">'y'</span>);
    element.addClass(board.layout[id]);
  });

  $(<span class="hljs-string">`#<span class="hljs-subst">${picked}</span>`</span>).addClass(<span class="hljs-string">'picked'</span>);
};</pre></div>
        
      
        
        <p>We use the <code>removeClass</code> function to clear any <code>x</code>, <code>y</code>, or <code>picked</code> classes
that might have been previously set. That way the board renders cleanly each
time. We also add the <code>picked</code> class to any picked element. It’s okay if
there’s no picked element. An <code>$(&#39;#undefined&#39;)</code> call won’t find anything, so
nothing gets picked.</p>
<p>To keep the rendered board up to date, we could use a loop and redraw it
periodically. However, we only really need to redraw the board when something
changes. So we’ll give ourselves a way to invalidate the rendering and
trigger a redraw.</p>

        
          <div class='highlight'><pre>
Renderer.invalidate = <span class="hljs-function">(<span class="hljs-params">board, picked</span>) =&gt;</span> {
  requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> Renderer.render(board, picked));
};</pre></div>
        
      
        
        <p>Using <a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" title="Various (MDN): window.requestAnimationFrame"><code>requestAnimationFrame</code></a> lets the browser queue all our style
changes and apply them before the next repaint. With more time sensitive
animations, this helps avoid flickering.</p>
<p>Let’s run the same test as before, but this time we’ll render the board.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testRenderer</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> starting = Board.create();
  Renderer.invalidate(starting);

  <span class="hljs-keyword">const</span> playing = Board.move(starting, [<span class="hljs-string">'a1-c4'</span>, <span class="hljs-string">'b5-a4'</span>]);
  Renderer.invalidate(playing, <span class="hljs-string">'b1'</span>);
}());</code></pre><p>Here’s what that looks like.</p>
<div class="board">
  <div class="y"></div>
  <div></div>
  <div class="y"></div>
  <div class="y"></div>
  <div></div>
  <div class="x"></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div></div>
  <div class="x picked"></div>
  <div class="x"></div>
</div>

<p>So what’s the next move?</p>
<p>X could play “b1-c4” and try to stack pieces on top of each other. That would
be illegal, but the <code>Board.move</code> function doesn’t know the rules of the game.
Just like how we don’t want the board to know or care how it’s displayed, we
also don’t want it to know or care about rules. We’ll figure those out next.</p>
<hr>

        
      
        
        <p>Let’s write some rules.</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">const</span> Rules = {};</pre></div>
        
      
        
        <p>You can move your own pieces.</p>

        
          <div class='highlight'><pre>
Rules.pickable = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> spaces = <span class="hljs-built_in">Object</span>.keys(board.layout);
  <span class="hljs-keyword">return</span> spaces.filter(<span class="hljs-function"><span class="hljs-params">space</span> =&gt;</span> board.layout[space] === player);
};</pre></div>
        
      
        
        <p>You can move a piece to an empty non-starting space.</p>

        
          <div class='highlight'><pre>
Rules.starting = <span class="hljs-function">(<span class="hljs-params">board</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> spaces = <span class="hljs-built_in">Object</span>.keys(board.layout);
  <span class="hljs-keyword">return</span> spaces.filter(<span class="hljs-function"><span class="hljs-params">space</span> =&gt;</span> space.charAt(<span class="hljs-number">1</span>) === <span class="hljs-string">'1'</span> || space.charAt(<span class="hljs-number">1</span>) === <span class="hljs-string">'5'</span>);
};

Rules.playable = <span class="hljs-function">(<span class="hljs-params">board</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> spaces = <span class="hljs-built_in">Object</span>.keys(board.layout);
  <span class="hljs-keyword">const</span> empty = spaces.filter(<span class="hljs-function"><span class="hljs-params">space</span> =&gt;</span> !board.layout[space]);

  <span class="hljs-keyword">const</span> starting = Rules.starting(board);
  <span class="hljs-keyword">return</span> empty.filter(<span class="hljs-function"><span class="hljs-params">space</span> =&gt;</span> starting.indexOf(space) &lt; <span class="hljs-number">0</span>);
};</pre></div>
        
      
        
        <p>So every combination of a piece you can pick up and a space you can play
into, is an allowed move.</p>

        
          <div class='highlight'><pre>
Rules.moves = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> pickable = Rules.pickable(board, player);
  <span class="hljs-keyword">const</span> playable = Rules.playable(board);
  <span class="hljs-keyword">const</span> moves = [];

  pickable.forEach(<span class="hljs-function">(<span class="hljs-params">start</span>) =&gt;</span> {
    playable.forEach(<span class="hljs-function">(<span class="hljs-params">end</span>) =&gt;</span> {
      moves.push(<span class="hljs-string">`<span class="hljs-subst">${start}</span>-<span class="hljs-subst">${end}</span>`</span>);
    });
  });

  <span class="hljs-keyword">return</span> moves;
};</pre></div>
        
      
        
        <p>That’s enough to write a tiny test. Continuing the game above, X has three
pieces, and there are seven empty spaces to play into. So that’s twenty-one
allowed moves.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testMovementRules</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> starting = Board.create();
  <span class="hljs-keyword">const</span> playing = Board.move(starting, [<span class="hljs-string">'a1-c4'</span>, <span class="hljs-string">'b5-a4'</span>]);
  <span class="hljs-keyword">const</span> moves = Rules.moves(playing, <span class="hljs-string">'x'</span>);

  assert(moves.length === <span class="hljs-number">21</span>);
}());</code></pre><p>The game is over when either player wins by getting three of their pieces in
a row. Diagonals don’t count though, and we don’t want to include pieces in
starting spaces.</p>

        
          <div class='highlight'><pre>
Rules.winner = <span class="hljs-function">(<span class="hljs-params">board</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> files = board.files.slice();
  <span class="hljs-keyword">const</span> ranks = board.ranks.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);

  <span class="hljs-keyword">let</span> winner;

  ranks.forEach(<span class="hljs-function">(<span class="hljs-params">rank</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!winner) {
      <span class="hljs-keyword">const</span> players = [];

      files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
        players.push(board.layout[file + rank]);
      });

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(players).size === <span class="hljs-number">1</span> &amp;&amp; players[<span class="hljs-number">0</span>]) {
        [winner] = players;
      }
    }
  });

  files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (!winner) {
      <span class="hljs-keyword">const</span> players = [];

      ranks.forEach(<span class="hljs-function">(<span class="hljs-params">rank</span>) =&gt;</span> {
        players.push(board.layout[file + rank]);
      });

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(players).size === <span class="hljs-number">1</span> &amp;&amp; players[<span class="hljs-number">0</span>]) {
        [winner] = players;
      }
    }
  });

  <span class="hljs-keyword">return</span> winner;
};</pre></div>
        
      
        
        <p>The decision to test for file wins first (vertical) instead of rank wins
(horizontal) is totally arbitrary. The <code>slice()</code> function is used to get
copies of the ranks and files from the board without changing it.</p>
<p>We’ll write a test to cover all four cases:</p>
<ol>
<li>Starting space don’t count.</li>
<li>Three in a row horizontally wins.</li>
<li>Three in a row vertically wins.</li>
<li>Three in a row diagonally doesn’t count.</li>
</ol>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testWinnerRules</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> starting = Board.create();
  assert(Rules.winner(starting) === <span class="hljs-literal">undefined</span>);

  <span class="hljs-keyword">const</span> horizontal = Board.move(starting, [<span class="hljs-string">'a1-a2'</span>, <span class="hljs-string">'b1-b2'</span>, <span class="hljs-string">'c1-c2'</span>]);
  assert(Rules.winner(horizontal) === <span class="hljs-string">'x'</span>);

  <span class="hljs-keyword">const</span> vertical = Board.move(starting, [<span class="hljs-string">'a5-a4'</span>, <span class="hljs-string">'b5-a3'</span>, <span class="hljs-string">'c5-a2'</span>]);
  assert(Rules.winner(vertical) === <span class="hljs-string">'y'</span>);

  <span class="hljs-keyword">const</span> diagonal = Board.move(starting, [<span class="hljs-string">'a1-a2'</span>, <span class="hljs-string">'b1-b3'</span>, <span class="hljs-string">'c1-c4'</span>]);
  assert(Rules.winner(diagonal) === <span class="hljs-literal">undefined</span>);
}());</code></pre><p>There are other edge cases we could cover, like three in a row vertically
where one of the pieces is in a starting space. But the goal here isn’t
exhaustive test coverage. Often the best way to test a game is to start
playing it. To do that, we’ll need an oppontent.</p>
<hr>

        
      
        
        <p>Let’s write an AI.</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">const</span> AI = {};</pre></div>
        
      
        
        <p>Our AI can use the rules to find all the winning moves available to it.</p>

        
          <div class='highlight'><pre>
AI.winning = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> moves = Rules.moves(board, player);
  <span class="hljs-keyword">return</span> moves.filter(<span class="hljs-function">(<span class="hljs-params">move</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> test = Board.move(board, [move]);
    <span class="hljs-keyword">return</span> Rules.winner(test) === player;
  });
};</pre></div>
        
      
        
        <p>Our AI can also use the rules to find all the blocking moves available to it.
Assume it’s the other player’s turn. What move would they make to win? If the
AI can find a move it can make that puts its piece in the same space, that’s
a blocking move.</p>

        
          <div class='highlight'><pre>
AI.opponent = <span class="hljs-function"><span class="hljs-params">player</span> =&gt;</span> (player === <span class="hljs-string">'x'</span> ? <span class="hljs-string">'y'</span> : <span class="hljs-string">'x'</span>);

AI.blocking = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> opponent = AI.opponent(player);
  <span class="hljs-keyword">const</span> winning = AI.winning(board, opponent).map(<span class="hljs-function"><span class="hljs-params">move</span> =&gt;</span> move.slice(<span class="hljs-number">3</span>));
  <span class="hljs-keyword">const</span> blocking = Rules.moves(board, player);
  <span class="hljs-keyword">return</span> blocking.filter(<span class="hljs-function"><span class="hljs-params">move</span> =&gt;</span> winning.indexOf(move.slice(<span class="hljs-number">3</span>)) &gt; <span class="hljs-number">-1</span>);
};</pre></div>
        
      
        
        <p>Our AI wants to get all its pieces on the board. So it can use the rules to
find moves that originate from a starting space.</p>

        
          <div class='highlight'><pre>
AI.starting = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> moves = Rules.moves(board, player);
  <span class="hljs-keyword">const</span> starting = Rules.starting(board);
  <span class="hljs-keyword">return</span> moves.filter(<span class="hljs-function"><span class="hljs-params">move</span> =&gt;</span> starting.indexOf(move.slice(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>)) &gt; <span class="hljs-number">0</span>);
};</pre></div>
        
      
        
        <p>Our AI is simple. It plays a winning move if it sees one. Otherwise it plays
a blocking move. If it doesn’t see any winning or blocking moves, it plays a
legal move. It prefers to play starting moves first.</p>

        
          <div class='highlight'><pre>
AI.moves = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> winning = AI.winning(board, player);
  <span class="hljs-keyword">if</span> (winning.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> winning;
  }

  <span class="hljs-keyword">const</span> blocking = AI.blocking(board, player);
  <span class="hljs-keyword">if</span> (blocking.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> blocking;
  }

  <span class="hljs-keyword">const</span> starting = AI.starting(board, player);
  <span class="hljs-keyword">if</span> (starting.length &gt; <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">return</span> starting;
  }

  <span class="hljs-keyword">return</span> Rules.moves(board, player);
};

AI.move = <span class="hljs-function">(<span class="hljs-params">board, player</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> moves = AI.moves(board, player);
  <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * moves.length);
  <span class="hljs-keyword">return</span> moves[index];
};</pre></div>
        
      
        
        <p>Because our AI is stateless, and all its functions take a <code>player</code> argument,
it can play our game against itself.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testAI</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> board = Board.create();
  <span class="hljs-keyword">let</span> winner;

  <span class="hljs-keyword">while</span> (!winner) {
    <span class="hljs-keyword">const</span> xmove = AI.move(board, <span class="hljs-string">'x'</span>);
    board = Board.move(board, [xmove]);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`x plays <span class="hljs-subst">${xmove}</span> resulting in`</span>, <span class="hljs-built_in">JSON</span>.stringify(board.layout));

    <span class="hljs-keyword">const</span> ymove = AI.move(board, <span class="hljs-string">'y'</span>);
    board = Board.move(board, [ymove]);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`y plays <span class="hljs-subst">${ymove}</span> resulting in`</span>, <span class="hljs-built_in">JSON</span>.stringify(board.layout));

    winner = Rules.winner(board);
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${winner}</span> wins!`</span>);
}());</code></pre><p>It looks like our AI works, but we won’t really know until we play a game
against it. Let’s combine our board, rules, and AI into something that can
drive our renderer.</p>
<hr>

        
      
        
        <p>Let’s write a game engine.</p>

        
          <div class='highlight'><pre>
<span class="hljs-keyword">const</span> Engine = {};</pre></div>
        
      
        
        <p>A fixed unit of time in video games is often called a tick. With every tick
the game state changes, and the board needs to be rendered. For our game, a
move by the player and response from the AI is a tick.</p>

        
          <div class='highlight'><pre>
Engine.tick = <span class="hljs-function">(<span class="hljs-params">board, player, start, end</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (Rules.winner(board)) {
    <span class="hljs-keyword">return</span> [Board.clone(board), <span class="hljs-literal">undefined</span>];
  }

  <span class="hljs-keyword">let</span> move = <span class="hljs-string">`<span class="hljs-subst">${start}</span>-<span class="hljs-subst">${end}</span>`</span>;
  <span class="hljs-keyword">if</span> (Rules.moves(board, player).indexOf(move) &gt; <span class="hljs-number">-1</span>) {
    <span class="hljs-keyword">let</span> next = Board.move(board, [move]);

    <span class="hljs-keyword">if</span> (Rules.winner(next) !== player) {
      move = AI.move(next, AI.opponent(player));
      next = Board.move(next, [move]);
    }

    <span class="hljs-keyword">return</span> [next, <span class="hljs-literal">undefined</span>];
  }

  <span class="hljs-keyword">const</span> pickable = Rules.pickable(board, player);
  <span class="hljs-keyword">const</span> picked = [end, start].filter(<span class="hljs-function"><span class="hljs-params">space</span> =&gt;</span> pickable.indexOf(space) &gt; <span class="hljs-number">-1</span>);
  <span class="hljs-keyword">return</span> [Board.clone(board), ...picked];
};</pre></div>
        
      
        
        <p>The <code>Engine.tick</code> function takes a board, a player, and a move. It returns
a board and a picked piece. That response matches the input to the
<code>Renderer.render</code> function, so we can draw the board with every tick.</p>
<p>If either the player or AI has won, we return the board unchanged with
nothing picked.</p>
<p>If the player is allowed to make their move, they take it. If the player
didn’t make a winning move, the AI gets a turn. Either way, we return the
updated board with nothing picked.</p>
<p>If the player tried to make an illegal move, we return the board unchanged.
But we also need to figure out what space to leave picked. We know the player
picked <code>start</code> and then picked <code>end</code>, so we return the <em>last</em> valid space
they chose. This lets the player pick a piece and then change their mind and
pick a different piece.</p>
<p>Let’s write a test to check illegal moves.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testIllegalMoves</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">const</span> board = Board.create();
  <span class="hljs-keyword">const</span> empty = <span class="hljs-string">'a2'</span>;
  <span class="hljs-keyword">const</span> ai = <span class="hljs-string">'a5'</span>;
  <span class="hljs-keyword">const</span> player1 = <span class="hljs-string">'a1'</span>;
  <span class="hljs-keyword">const</span> player2 = <span class="hljs-string">'b1'</span>;

  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, ai, empty)[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span>);
  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, ai, ai)[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span>);
  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, ai, player1)[<span class="hljs-number">1</span>] === player1);

  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, empty, empty)[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span>);
  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, empty, ai)[<span class="hljs-number">1</span>] === <span class="hljs-literal">undefined</span>);
  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, empty, player1)[<span class="hljs-number">1</span>] === player1);

  <span class="hljs-comment">// `player1` to `empty` is a valid move, so we don't need to test it.</span>
  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, player1, ai)[<span class="hljs-number">1</span>] === player1);
  assert(Engine.tick(board, <span class="hljs-string">'x'</span>, player1, player2)[<span class="hljs-number">1</span>] === player2);
}());</code></pre><p>Because our engine is stateless, we can use the AI to play our game against
the engine. With each tick, the board updates with moves from both players.</p>
<pre><code>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">testEngine</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">let</span> board = Board.create();
  <span class="hljs-keyword">let</span> winner;

  <span class="hljs-keyword">while</span> (!winner) {
    <span class="hljs-keyword">const</span> xmove = AI.move(board, <span class="hljs-string">'x'</span>);
    [board] = Engine.tick(board, <span class="hljs-string">'x'</span>, ...xmove.split(<span class="hljs-string">'-'</span>));
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`x plays <span class="hljs-subst">${xmove}</span> resulting in`</span>, <span class="hljs-built_in">JSON</span>.stringify(board.layout));

    winner = Rules.winner(board);
  }

  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">${winner}</span> wins!`</span>);
}());</code></pre><p>It looks like our engine works. Let’s wire it up to our renderer so we can
play against the AI.</p>
<hr>

        
      
        
        <p>Let’s write a game.</p>

        
          <div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">game</span>(<span class="hljs-params"></span>) </span>{</pre></div>
        
      
        
        <p>Our game keeps track of three things. There’s a <code>board</code> for the game state,
an <code>input</code> list of spaces on the board the player has selected, and a <code>picked</code>
space that tracks the currently selected space.</p>

        
          <div class='highlight'><pre>  <span class="hljs-keyword">let</span> board = Board.create();
  <span class="hljs-keyword">let</span> input = [];
  <span class="hljs-keyword">let</span> picked;</pre></div>
        
      
        
        <p>When the player selects a space we add the <code>picked</code> class to it, add the
selected space to the <code>input</code> list, tick the game engine, and render the
board. If this was a real time video game, we’d run that same loop (respond
to player input, tick the game engine, render the world) forever. Since
this is a turn based game, we only need to run it when the player does
something.</p>

        
          <div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onBoard</span>(<span class="hljs-params">element</span>) </span>{
    element.addClass(<span class="hljs-string">'picked'</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">offBoard</span>(<span class="hljs-params">element</span>) </span>{
    input.push(element.unwrap().id);
    [board, picked] = Engine.tick(board, <span class="hljs-string">'x'</span>, ...input);
    input = picked ? [picked] : [];
    Renderer.invalidate(board, picked);
  }</pre></div>
        
      
        
        <p>We also include a reset button that clears everything out and starts the
game over.</p>

        
          <div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reset</span>(<span class="hljs-params"></span>) </span>{
    board = Board.create();
    input = [];
    picked = <span class="hljs-literal">undefined</span>;
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onReset</span>(<span class="hljs-params">element</span>) </span>{
    element.addClass(<span class="hljs-string">'picked'</span>);
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">offReset</span>(<span class="hljs-params">element</span>) </span>{
    element.removeClass(<span class="hljs-string">'picked'</span>);
    reset();
    Renderer.invalidate(board, picked);
  }</pre></div>
        
      
        
        <p>Finally, we wire up click handlers for the board spaces and the reset
button. Then we initialize the game and render the starting board.</p>

        
          <div class='highlight'><pre>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">const</span> $ = <span class="hljs-built_in">window</span>.jQuery;

    $(<span class="hljs-string">'#reset'</span>).click(onReset, offReset);
    <span class="hljs-built_in">Object</span>.keys(board.layout).forEach(<span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> $(<span class="hljs-string">`#<span class="hljs-subst">${id}</span>`</span>).click(onBoard, offBoard));

    reset();
    Renderer.invalidate(board, picked);
  }

  <span class="hljs-built_in">window</span>.onload = play;</pre></div>
        
      
        
        <p>Because our game has state, it’s not just pure functions any more, we’re
using an <a href="https://developer.mozilla.org/en-US/docs/Glossary/IIFE" title="Various (MDN): IIFE">IIFE</a> (Immediately Invoked Function Expression) to avoid
exposing that state to the outside world.</p>

        
          <div class='highlight'><pre>}());</pre></div>
        
      
        
        <p>And that’s how you make a video game.</p>

        
      
        
        <h2 id="appendix">Appendix: A Tiny jQuery Clone</h2>

        
          <div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">$</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params">selector</span>) </span>{
    <span class="hljs-keyword">if</span> (selector <span class="hljs-keyword">instanceof</span> Fn) {
      <span class="hljs-keyword">return</span> selector;
    }

    <span class="hljs-keyword">this</span>.element = selector;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> selector === <span class="hljs-string">'string'</span>) {
      <span class="hljs-keyword">if</span> (selector.indexOf(<span class="hljs-string">'#'</span>) === <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.getElementById(selector.slice(<span class="hljs-number">1</span>));
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  }

  Fn.prototype.addClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClass</span>(<span class="hljs-params">klass</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.element &amp;&amp; <span class="hljs-keyword">this</span>.element.classList &amp;&amp; klass) {
      <span class="hljs-keyword">this</span>.element.classList.add(klass);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  Fn.prototype.removeClass = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeClass</span>(<span class="hljs-params">klass</span>) </span>{
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.element &amp;&amp; <span class="hljs-keyword">this</span>.element.classList) {
      <span class="hljs-keyword">this</span>.element.classList.remove(klass);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  Fn.prototype.click = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">click</span>(<span class="hljs-params">start, end</span>) </span>{
    <span class="hljs-keyword">const</span> self = <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.element) {
      <span class="hljs-keyword">if</span> (<span class="hljs-string">'ontouchstart'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">document</span>.documentElement === <span class="hljs-literal">false</span>) {
        <span class="hljs-keyword">this</span>.element.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onmousedown</span>(<span class="hljs-params">mouseDownEvent</span>) </span>{
          <span class="hljs-keyword">if</span> (start) {
            start(self, mouseDownEvent);
          }
          <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onmousemove</span>(<span class="hljs-params">e</span>) </span>{
            e.preventDefault();
          };
          <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onmouseup</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (end) {
              end(self, e);
            }
            <span class="hljs-built_in">document</span>.onmousemove = <span class="hljs-literal">undefined</span>;
            <span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-literal">undefined</span>;
          };
        };
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.element.ontouchstart = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ontouchstart</span>(<span class="hljs-params">touchStartEvent</span>) </span>{
          <span class="hljs-keyword">if</span> (start) {
            start(self, touchStartEvent);
          }
          <span class="hljs-built_in">document</span>.ontouchmove = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ontouchmove</span>(<span class="hljs-params">e</span>) </span>{
            e.preventDefault();
          };
          <span class="hljs-built_in">document</span>.ontouchend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ontouchend</span>(<span class="hljs-params">e</span>) </span>{
            <span class="hljs-keyword">if</span> (end) {
              end(self, e);
            }
            <span class="hljs-built_in">document</span>.ontouchmove = <span class="hljs-literal">undefined</span>;
            <span class="hljs-built_in">document</span>.ontouchend = <span class="hljs-literal">undefined</span>;
          };
        };
      }
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };

  Fn.prototype.unwrap = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unwrap</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.element;
  };

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">root</span>(<span class="hljs-params">selector</span>) </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fn(selector);
  }

  <span class="hljs-built_in">window</span>.jQuery = root;
}());</pre></div>
        
      
      <div class="fleur">h</div>
    </div>
  </div>
</body>
</html>
